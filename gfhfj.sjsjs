import time
import hmac
import hashlib
import requests
from urllib.parse import urlencode
from datetime import datetime

# ==================== Settings ====================
API_KEY = '3C83F16189A34ADD2C8A9E03B74A8CB0'
API_SECRET = '12023f1321a3b209074d95ad303c9c0b'

# --- Telegram Settings ---
TELEGRAM_TOKEN = '8140237067:AAEAuuQDVtvT7HfMc11bcDgmhx7spt4X47g'
TELEGRAM_CHAT_ID = '1001181840'

PAIR = 'btc_usdt'           
CYCLE_AMOUNT = 0.00023          
MIN_BTC_LIMIT = 0.00011     

# --- Advanced Logic Settings ---
MIN_PROFIT_SPREAD = 0.003   
STOP_LOSS_PERCENT = 0.01    
TRAILING_STOP_PERCENT = 0.005  
MAX_GLOBAL_DIFF = 0.015     
SAFE_BUY_DISCOUNT = 0.005    
ORDER_MIN_AGE = 3           
# ===============================================

COIN_SYMBOL = PAIR.split('_')[0].lower()
FIAT_SYMBOL = PAIR.split('_')[1].lower()

last_buy_price = 0  
highest_price_after_buy = 0
last_order_time = 0
CACHED_CG_LIST = []
PAIR_MIN_AMOUNT = 0.0001 # YoBit default minimum for many pairs

def send_telegram_msg(message):
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
        payload = {"chat_id": TELEGRAM_CHAT_ID, "text": message, "parse_mode": "Markdown"}
        requests.post(url, json=payload, timeout=10)
    except: pass

def log(message, send_tg=False):
    log_text = f"[{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}] {message}"
    print(log_text)
    try:
        with open("trade_logs.txt", "a", encoding="utf-8") as f:
            f.write(log_text + "\n")
    except: pass
    if send_tg: send_telegram_msg(message)

def get_coingecko_id(symbol):
    global CACHED_CG_LIST
    symbol = symbol.lower()
    try:
        priority_ids = {'ton': 'the-open-network', 'usdt': 'tether', 'btc': 'bitcoin', 'eth': 'ethereum'}
        if symbol in priority_ids: return priority_ids[symbol]
        if not CACHED_CG_LIST:
            url = "https://api.coingecko.com/api/v3/coins/list"
            CACHED_CG_LIST = requests.get(url, timeout=10).json()
        for coin in CACHED_CG_LIST:
            if coin['symbol'].lower() == symbol: return coin['id']
        return symbol 
    except: return symbol

GLOBAL_COIN_ID = get_coingecko_id(COIN_SYMBOL)
log(f"üöÄ BOT STARTED: {PAIR.upper()}", send_tg=True)

def yobit_api_call(method, params={}):
    try:
        params.update({'method': method, 'nonce': int(time.time() - 1700000000)})
        post_data = urlencode(params)
        sign = hmac.new(API_SECRET.encode(), post_data.encode(), hashlib.sha512).hexdigest()
        headers = {'Sign': sign, 'Key': API_KEY, 'Content-Type': 'application/x-www-form-urlencoded'}
        res = requests.post('https://yobit.net/tapi/', data=post_data, headers=headers, timeout=10).json()
        if res.get('error'): 
            log(f"‚ùå API Error ({method}): {res['error']}")
        return res
    except: return None

def get_market_info():
    """‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡¶¨‡ßá ‡¶è‡¶á ‡¶™‡ßá‡¶Ø‡¶º‡¶æ‡¶∞‡ßá ‡¶∏‡¶∞‡ßç‡¶¨‡¶®‡¶ø‡¶Æ‡ßç‡¶® ‡¶ï‡¶§ ‡¶ü‡ßç‡¶∞‡ßá‡¶° ‡¶ï‡¶∞‡¶æ ‡¶Ø‡¶æ‡¶¨‡ßá"""
    global PAIR_MIN_AMOUNT
    try:
        res = requests.get(f'https://yobit.net/api/3/info', timeout=10).json()
        pair_data = res.get('pairs', {}).get(PAIR, {})
        PAIR_MIN_AMOUNT = pair_data.get('min_amount', 0.0001)
    except: pass

def get_recent_trades():
    try:
        url = f'https://yobit.net/api/3/trades/{PAIR}?limit=20'
        res = requests.get(url, headers={'User-Agent': 'Mozilla/5.0'}, timeout=10).json()
        trades = res.get(PAIR, [])
        if len(trades) < 20: return 999
        return trades[0]['timestamp'] - trades[-1]['timestamp']
    except: return 999

def get_dynamic_global_price():
    try:
        target_fiat = 'usd' if FIAT_SYMBOL == 'usdt' else FIAT_SYMBOL
        url = f"https://api.coingecko.com/api/v3/simple/price?ids={GLOBAL_COIN_ID}&vs_currencies={target_fiat}"
        res = requests.get(url, timeout=10).json()
        return float(res[GLOBAL_COIN_ID][target_fiat]) if GLOBAL_COIN_ID in res else None
    except: return None

def run_bot():
    global last_buy_price, highest_price_after_buy, last_order_time
    get_market_info() # ‡¶∂‡ßÅ‡¶∞‡ßÅ‡¶§‡ßá ‡¶Æ‡¶ø‡¶®‡¶ø‡¶Æ‡¶æ‡¶Æ ‡¶ü‡ßç‡¶∞‡ßá‡¶° ‡¶è‡¶Æ‡¶æ‡¶â‡¶®‡ßç‡¶ü ‡¶ú‡ßá‡¶®‡ßá ‡¶®‡ßá‡¶ì‡ßü‡¶æ
    
    while True:
        try:
            market_url = f'https://yobit.net/api/3/depth/{PAIR}?limit=15'
            market_res = requests.get(market_url, timeout=10).json()[PAIR]
            asks, bids = market_res['asks'], market_res['bids']
            global_price = get_dynamic_global_price()
            trade_speed = get_recent_trades()
            
            if not global_price:
                time.sleep(5); continue

            info = yobit_api_call('getInfo')
            if not info or not info.get('return'): 
                time.sleep(5); continue
            
            funds = info['return']['funds']
            free_coin = float(funds.get(COIN_SYMBOL, 0))
            free_fiat = float(funds.get(FIAT_SYMBOL, 0))
            
            active = yobit_api_call('ActiveOrders', {'pair': PAIR})
            my_orders = active.get('return', {}) if active and active.get('success') == 1 else {}

            best_sell = float(asks[0][0])
            best_buy = float(bids[0][0])
            discount_gate = global_price * (1 - SAFE_BUY_DISCOUNT)
            needed_to_buy = round(CYCLE_AMOUNT - free_coin, 8)

            # --- SMART ADAPTIVE BUY LOGIC ---
            if needed_to_buy >= PAIR_MIN_AMOUNT: # ‡¶Æ‡¶ø‡¶®‡¶ø‡¶Æ‡¶æ‡¶Æ ‡¶è‡¶Æ‡¶æ‡¶â‡¶®‡ßç‡¶ü ‡¶ö‡ßá‡¶ï
                target_buy = 0
                if trade_speed < 60: # Fast Market
                    target_buy = round(best_buy + 0.00000002, 8)
                    reason = "üî• Fast Mode"
                else: # Slow Market
                    best_sub = 0
                    for b in bids:
                        if float(b[0]) <= discount_gate:
                            best_sub = float(b[0])
                            break
                    target_buy = round(best_sub + 0.00000002, 8) if best_sub > 0 else round(discount_gate, 8)
                    reason = "‚ùÑÔ∏è Slow Mode"

                # ‡¶™‡ßç‡¶∞‡¶´‡¶ø‡¶ü ‡¶Æ‡¶æ‡¶∞‡ßç‡¶ú‡¶ø‡¶® ‡¶™‡ßç‡¶∞‡¶ü‡ßá‡¶ï‡¶∂‡¶®
                if (best_sell - target_buy) / target_buy < MIN_PROFIT_SPREAD:
                    target_buy = round(best_sell * (1 - (MIN_PROFIT_SPREAD + 0.001)), 8)

                # ‡¶™‡¶∞‡ßç‡¶Ø‡¶æ‡¶™‡ßç‡¶§ ‡¶°‡¶≤‡¶æ‡¶∞ ‡¶Ü‡¶õ‡ßá ‡¶ï‡¶ø ‡¶®‡¶æ ‡¶ö‡ßá‡¶ï
                if free_fiat >= (target_buy * needed_to_buy):
                    my_buy = next((o for o in my_orders.values() if o['type'] == 'buy'), None)
                    if not my_buy or abs(float(my_buy['rate']) - target_buy) > 1e-8:
                        if (time.time() - last_order_time) > ORDER_MIN_AGE:
                            for oid in [oid for oid, o in my_orders.items() if o['type'] == 'buy']:
                                yobit_api_call('CancelOrder', {'order_id': oid})
                            res = yobit_api_call('Trade', {'pair': PAIR, 'type': 'buy', 'rate': target_buy, 'amount': needed_to_buy})
                            if res and res.get('success') == 1:
                                last_buy_price, highest_price_after_buy = target_buy, target_buy
                                last_order_time = time.time()
                                log(f"‚úÖ BUY: {target_buy} | {reason}", send_tg=True)

            # --- SMART SELL LOGIC ---
            if free_coin >= PAIR_MIN_AMOUNT:
                if best_buy > highest_price_after_buy: highest_price_after_buy = best_buy
                
                trailing_stop = highest_price_after_buy * (1 - TRAILING_STOP_PERCENT)
                stop_loss = last_buy_price * (1 - STOP_LOSS_PERCENT)
                target_sell = round(best_sell - 0.00000002, 8)
                msg = "Top Comp"

                if best_buy <= trailing_stop and highest_price_after_buy > last_buy_price:
                    target_sell, msg = best_buy, "Trailing Stop"
                elif last_buy_price > 0 and best_buy <= stop_loss:
                    target_sell, msg = best_buy, "Stop-Loss"
                elif last_buy_price > 0 and target_sell < (last_buy_price * (1 + MIN_PROFIT_SPREAD)):
                    if len(asks) > 1: target_sell, msg = round(float(asks[1][0]) - 0.00000002, 8), "Margin Prot"

                my_sell = next((o for o in my_orders.values() if o['type'] == 'sell'), None)
                if not my_sell or abs(float(my_sell['rate']) - target_sell) > 1e-8:
                    if (time.time() - last_order_time) > ORDER_MIN_AGE:
                        for oid in [oid for oid, o in my_orders.items() if o['type'] == 'sell']:
                            yobit_api_call('CancelOrder', {'order_id': oid})
                        res = yobit_api_call('Trade', {'pair': PAIR, 'type': 'sell', 'rate': target_sell, 'amount': free_coin})
                        if res and res.get('success') == 1:
                            p_l = ""
                            if last_buy_price > 0:
                                diff = ((target_sell - last_buy_price) / last_buy_price) * 100
                                p_l = f" | Result: {'üí∞' if diff > 0 else 'üîª'} {diff:.2f}%"
                            log(f"üí∞ SELL: {target_sell} | {msg}{p_l}", send_tg=True)
                            last_order_time = time.time()

            print(f"ST: {trade_speed}s | GL: {global_price} | T_B: {target_buy if 'target_buy' in locals() else 'N/A'}", end='\r')
            time.sleep(3)
        except Exception as e:
            log(f"‚ö†Ô∏è Error: {e}")
            time.sleep(10)

if __name__ == "__main__":
    run_bot()
